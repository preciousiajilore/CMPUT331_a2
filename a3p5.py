#!/usr/bin/python3

#---------------------------------------------------------------
#
# CMPUT 331 Student Submission License
# Version 1.0
# Copyright 2026 Precious Ajilore
#
# Redistribution is forbidden in all circumstances. Use of this software
# without explicit authorization from the author is prohibited.
#
# This software was produced as a solution for an assignment in the course
# CMPUT 331 - Computational Cryptography at the University of
# Alberta, Canada. This solution is confidential and remains confidential 
# after it is submitted for grading.
#
# Copying any part of this solution without including this copyright notice
# is illegal.
#
# If any portion of this software is included in a solution submitted for
# grading at an educational institution, the submitter will be subject to
# the sanctions for plagiarism at that institution.
#
# If this software is found in any public website or public repository, the
# person finding it is kindly requested to immediately report, including 
# the URL or other repository locating information, to the following email
# address:
#
#          gkondrak <at> ualberta.ca
#
#---------------------------------------------------------------

"""
CMPUT 331 Assignment 3 Student Solution
January 2026
Author: Precious Ajilore

In problem 4, you were able to “hack” Alice’s algorithm by obtaining a, b, and c and thus
predict all of its future output (you predicted R7, but of course, since a, b, and c are fixed, you
could predict any quantity of future values).

In this problem, you will automate this process.
Complete the module “a3p5.py” by implementing the function “crack rng(m, sequence)”,
where m is a prime number, and sequence is list of five consecutive numbers which are
generated by the generator (i.e. [R2, R3, R4, R5, R6]) and are all between 0 and m − 1, inclusive.

This function must return a list of integers [a, b, c], where a, b, and c are the keys for the
provided random generator at problem 3, with modulus m, which were used to generate the
input sequence. It is guaranteed that a and b are non-zero.

Hint: While not advisable in practice, it is perfectly valid for our algorithm to have c = 0,
and still have a, b̸ = 0. Your crack rng function must be able to crack RNGs with c = 0, a, b̸ = 0,
still returning the three-element list [a, b, c]. We guaranteed that there is a unique solution for
a, b, and c.

The code for this problem should be able to crack sequences generated by the code in
Problem 3. For example:
>>> crack_rng(17, random_generator(3, 5, 9, 17, 11, 6, 5))
[3, 5, 9]
"""

def crack_rng(m, sequence):
    """
    Docstring for crack_rng
    
    :param m: Description
    :param sequence: Description

    """

    r2, r3, r4, r5, r6 = tuple(sequence)
    
    x = (r3 - r2) % m
    y = (r4 - r3) % m
    z = (r5 - r4) % m
    w = (r6 - r5) % m

    # Determinant
    D = (y*y - z*x) % m
    if D == 0:
        raise ValueError("Cannot solve: determinant is 0 mod m")

    invD = pow(D, m-2, m)  # since m is prime

    # Solve for a and b
    a = ((z*y - w*x) % m) * invD % m
    b = ((w*y - z*z) % m) * invD % m

    # Solve for c
    c = (r4 - a*r3 - b*r2) % m

    return [a, b, c]


def test():
    assert crack_rng(17, [14, 13, 16, 3, 13]) == [3, 5, 9]
    
    
from sys import flags

if __name__ == "__main__" and not flags.interactive:
    test()